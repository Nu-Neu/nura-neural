{
  "name": "WF1: Content Ingestion Pipeline",
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "minutes",
              "minutesInterval": 15
            }
          ]
        }
      },
      "id": "schedule-rss",
      "name": "Schedule RSS (15min)",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [260, 300],
      "notes": "REQ-ING-001: Poll RSS feeds every 15 minutes"
    },
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "minutes",
              "minutesInterval": 5
            }
          ]
        }
      },
      "id": "schedule-twitter-priority",
      "name": "Schedule Twitter Priority (5min)",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [260, 520],
      "notes": "REQ-ING-002: High-priority accounts polled every 5 minutes"
    },
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "minutes",
              "minutesInterval": 15
            }
          ]
        }
      },
      "id": "schedule-twitter-standard",
      "name": "Schedule Twitter Standard (15min)",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [260, 720],
      "notes": "REQ-ING-002: Standard accounts polled every 15 minutes"
    },
    {
      "parameters": {
        "operation": "select",
        "query": "SELECT check_workflow_health('WF1_Ingestion_RSS') as can_proceed",
        "options": {}
      },
      "id": "check-circuit-rss",
      "name": "Check Circuit Breaker RSS",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [480, 300],
      "credentials": {
        "postgres": {
          "id": "nura-postgres",
          "name": "Nura PostgreSQL"
        }
      },
      "notes": "REQ-ING-005: Circuit breaker pattern"
    },
    {
      "parameters": {
        "operation": "select",
        "query": "SELECT check_workflow_health('WF1_Ingestion_Twitter') as can_proceed",
        "options": {}
      },
      "id": "check-circuit-twitter",
      "name": "Check Circuit Breaker Twitter",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [480, 620],
      "credentials": {
        "postgres": {
          "id": "nura-postgres",
          "name": "Nura PostgreSQL"
        }
      },
      "notes": "REQ-ING-005: Circuit breaker pattern"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "circuit-check",
              "leftValue": "={{ $json.can_proceed }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "if-circuit-open-rss",
      "name": "IF Circuit Open RSS",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [700, 300]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "circuit-check",
              "leftValue": "={{ $json.can_proceed }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "if-circuit-open-twitter",
      "name": "IF Circuit Open Twitter",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [700, 620]
    },
    {
      "parameters": {
        "method": "GET",
        "url": "={{ $env.MINIFLUX_URL }}/v1/entries",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "status",
              "value": "unread"
            },
            {
              "name": "limit",
              "value": "100"
            }
          ]
        },
        "options": {
          "timeout": 30000
        }
      },
      "id": "miniflux-api",
      "name": "Miniflux Get Entries",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [920, 240],
      "credentials": {
        "httpHeaderAuth": {
          "id": "miniflux-auth",
          "name": "Miniflux API Key"
        }
      },
      "onError": "continueErrorOutput",
      "notes": "REQ-ING-001: GET /v1/entries?status=unread&limit=100"
    },
    {
      "parameters": {
        "method": "GET",
        "url": "https://api.twitter.com/2/lists/{{ $env.TWITTER_PRIORITY_LIST_ID }}/tweets",
        "authentication": "oAuth2Api",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "tweet.fields",
              "value": "created_at,author_id,entities,public_metrics"
            },
            {
              "name": "expansions",
              "value": "author_id,attachments.media_keys"
            },
            {
              "name": "max_results",
              "value": "100"
            }
          ]
        },
        "options": {
          "timeout": 30000
        }
      },
      "id": "twitter-api-priority",
      "name": "Twitter API Priority",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [920, 560],
      "credentials": {
        "oAuth2Api": {
          "id": "twitter-oauth2",
          "name": "Twitter OAuth2"
        }
      },
      "onError": "continueErrorOutput",
      "notes": "REQ-ING-002: Twitter API v2 with priority-based intervals"
    },
    {
      "parameters": {
        "method": "GET",
        "url": "https://api.twitter.com/2/lists/{{ $env.TWITTER_STANDARD_LIST_ID }}/tweets",
        "authentication": "oAuth2Api",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "tweet.fields",
              "value": "created_at,author_id,entities,public_metrics"
            },
            {
              "name": "expansions",
              "value": "author_id,attachments.media_keys"
            },
            {
              "name": "max_results",
              "value": "100"
            }
          ]
        },
        "options": {
          "timeout": 30000
        }
      },
      "id": "twitter-api-standard",
      "name": "Twitter API Standard",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [920, 700],
      "credentials": {
        "oAuth2Api": {
          "id": "twitter-oauth2",
          "name": "Twitter OAuth2"
        }
      },
      "onError": "continueErrorOutput",
      "notes": "REQ-ING-002: Standard accounts every 15 minutes"
    },
    {
      "parameters": {
        "jsCode": "// Transform Miniflux entries to common format\nconst entries = $input.first().json.entries || [];\n\nreturn entries.map(entry => ({\n  json: {\n    external_id: `miniflux_${entry.id}`,\n    url: entry.url,\n    title: entry.title,\n    content: entry.content,\n    content_html: entry.content,\n    author: entry.author || null,\n    published_at: entry.published_at,\n    feed_id: entry.feed_id,\n    source_type: 'rss_article',\n    raw_data: entry\n  }\n}));"
      },
      "id": "transform-rss",
      "name": "Transform RSS Entries",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1140, 240]
    },
    {
      "parameters": {
        "jsCode": "// Transform Twitter tweets to common format\nconst data = $input.first().json;\nconst tweets = data.data || [];\nconst users = data.includes?.users || [];\nconst media = data.includes?.media || [];\n\nconst userMap = Object.fromEntries(users.map(u => [u.id, u]));\n\nreturn tweets.map(tweet => {\n  const author = userMap[tweet.author_id];\n  return {\n    json: {\n      external_id: `twitter_${tweet.id}`,\n      url: `https://twitter.com/${author?.username || 'user'}/status/${tweet.id}`,\n      title: tweet.text.substring(0, 100) + (tweet.text.length > 100 ? '...' : ''),\n      content: tweet.text,\n      content_html: null,\n      author: author?.name || author?.username || null,\n      published_at: tweet.created_at,\n      feed_id: null,\n      source_type: 'tweet',\n      twitter_author_id: tweet.author_id,\n      twitter_metrics: tweet.public_metrics,\n      raw_data: tweet\n    }\n  };\n});"
      },
      "id": "transform-twitter",
      "name": "Transform Twitter Tweets",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1140, 620]
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineAll",
        "options": {}
      },
      "id": "merge-sources",
      "name": "Merge All Sources",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [1360, 440]
    },
    {
      "parameters": {
        "jsCode": "// Calculate URL hash and SimHash for deduplication (REQ-ING-003)\nconst crypto = require('crypto');\n\n// FNV-1a 64-bit hash (for SimHash)\nfunction fnv1a64(str) {\n  let hash = 14695981039346656037n;\n  for (let i = 0; i < str.length; i++) {\n    hash ^= BigInt(str.charCodeAt(i));\n    hash = BigInt.asUintN(64, hash * 1099511628211n);\n  }\n  return hash;\n}\n\n// SimHash implementation for near-duplicate detection\nfunction simhash(text) {\n  if (!text || text.length < 10) return '0000000000000000';\n  \n  const words = text.toLowerCase()\n    .replace(/[^\\w\\s\\u0600-\\u06FF]/g, ' ')  // Keep Farsi chars\n    .split(/\\s+/)\n    .filter(w => w.length > 2);\n  \n  if (words.length < 3) return '0000000000000000';\n  \n  // Create 3-word shingles\n  const shingles = [];\n  for (let i = 0; i < words.length - 2; i++) {\n    shingles.push(words.slice(i, i + 3).join(' '));\n  }\n  \n  // Calculate hash vector\n  const hashVector = new Array(64).fill(0);\n  for (const shingle of shingles) {\n    const h = fnv1a64(shingle);\n    for (let i = 0; i < 64; i++) {\n      hashVector[i] += (h >> BigInt(i)) & 1n ? 1 : -1;\n    }\n  }\n  \n  // Convert to final hash\n  let result = 0n;\n  for (let i = 0; i < 64; i++) {\n    if (hashVector[i] > 0) result |= 1n << BigInt(i);\n  }\n  \n  return result.toString(16).padStart(16, '0');\n}\n\nreturn $input.all().map(item => {\n  const url = item.json.url || '';\n  const content = item.json.content || item.json.title || '';\n  \n  return {\n    json: {\n      ...item.json,\n      url_hash: crypto.createHash('sha256').update(url).digest('hex'),\n      sim_hash: simhash(content),\n      content_length: content.length\n    }\n  };\n});"
      },
      "id": "calc-hashes",
      "name": "Calculate Hashes (URL + SimHash)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1580, 440],
      "notes": "REQ-ING-003: URL hash (SHA-256) + SimHash (64-bit LSH)"
    },
    {
      "parameters": {
        "operation": "select",
        "query": "SELECT id, url_hash, sim_hash FROM items WHERE url_hash = $1",
        "options": {
          "queryReplacement": "={{ $json.url_hash }}"
        }
      },
      "id": "check-url-exists",
      "name": "Check URL Hash Exists",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [1800, 440],
      "credentials": {
        "postgres": {
          "id": "nura-postgres",
          "name": "Nura PostgreSQL"
        }
      },
      "notes": "REQ-ING-003: Exact duplicate check (Step 1)"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "exists-check",
              "leftValue": "={{ $json.length || 0 }}",
              "rightValue": 0,
              "operator": {
                "type": "number",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "if-url-exists",
      "name": "IF URL New",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [2020, 440]
    },
    {
      "parameters": {
        "operation": "select",
        "query": "SELECT id, sim_hash FROM items WHERE published_at > NOW() - interval '7 days' AND sim_hash IS NOT NULL LIMIT 1000",
        "options": {}
      },
      "id": "get-recent-simhashes",
      "name": "Get Recent SimHashes",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [2240, 500],
      "credentials": {
        "postgres": {
          "id": "nura-postgres",
          "name": "Nura PostgreSQL"
        }
      },
      "notes": "Get SimHashes from last 7 days for comparison"
    },
    {
      "parameters": {
        "jsCode": "// Compare SimHash for near-duplicate detection (REQ-ING-003)\nfunction hammingDistance(hash1, hash2) {\n  if (!hash1 || !hash2 || hash1 === '0000000000000000') return 64;\n  try {\n    const h1 = BigInt('0x' + hash1);\n    const h2 = BigInt('0x' + hash2);\n    let xor = h1 ^ h2;\n    let count = 0;\n    while (xor > 0n) {\n      count += Number(xor & 1n);\n      xor >>= 1n;\n    }\n    return count;\n  } catch (e) {\n    return 64; // Max distance if error\n  }\n}\n\nconst currentItem = $('Calculate Hashes (URL + SimHash)').item.json;\nconst recentItems = $input.first().json || [];\n\n// Handle case where recentItems is a single object or array\nconst itemsToCheck = Array.isArray(recentItems) ? recentItems : [recentItems];\n\n// Find closest match\nlet closestMatch = null;\nlet minDistance = 64;\n\nfor (const recent of itemsToCheck) {\n  if (!recent.sim_hash) continue;\n  const distance = hammingDistance(currentItem.sim_hash, recent.sim_hash);\n  if (distance < minDistance) {\n    minDistance = distance;\n    closestMatch = recent;\n  }\n}\n\n// Hamming distance <= 6 means ~90%+ similarity (duplicate)\n// Hamming distance 7-10 means possible reprint\nconst isDuplicate = minDistance <= 6;\nconst isReprint = minDistance > 6 && minDistance <= 10;\n\nreturn [{\n  json: {\n    ...currentItem,\n    is_duplicate: isDuplicate,\n    is_reprint: isReprint,\n    original_item_id: (isDuplicate || isReprint) ? closestMatch?.id : null,\n    similarity: 1 - (minDistance / 64),\n    hamming_distance: minDistance\n  }\n}];"
      },
      "id": "compare-simhash",
      "name": "Compare SimHash",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2460, 440],
      "notes": "REQ-ING-003: Near-duplicate check (Step 2) - Hamming distance â‰¤ 6 = duplicate"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "dup-check",
              "leftValue": "={{ $json.is_duplicate }}",
              "rightValue": false,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "if-not-duplicate",
      "name": "IF Not Duplicate",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [2680, 440]
    },
    {
      "parameters": {
        "operation": "select",
        "query": "SELECT sp.id as source_id, sp.name, sp.source_class, sp.base_score\nFROM source_profiles sp \nWHERE sp.feed_url ILIKE '%' || $1 || '%' \n   OR sp.identifier = $2 \nLIMIT 1",
        "options": {
          "queryReplacement": "={{ $json.feed_id || '' }},={{ $json.twitter_author_id || $json.external_id || '' }}"
        }
      },
      "id": "lookup-source",
      "name": "Lookup Source Profile",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [2900, 380],
      "credentials": {
        "postgres": {
          "id": "nura-postgres",
          "name": "Nura PostgreSQL"
        }
      },
      "notes": "Match feed_id/twitter_author_id to source_profiles"
    },
    {
      "parameters": {
        "method": "PUT",
        "url": "={{ $env.AZURE_BLOB_URL }}/nura-archive/{{ $json.url_hash }}.html{{ $env.AZURE_BLOB_SAS_TOKEN }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "x-ms-blob-type",
              "value": "BlockBlob"
            },
            {
              "name": "Content-Type",
              "value": "text/html; charset=utf-8"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "",
              "value": "={{ $json.content_html || $json.content || '' }}"
            }
          ]
        },
        "options": {
          "timeout": 30000
        }
      },
      "id": "upload-blob",
      "name": "Archive to Blob Storage",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [3120, 380],
      "onError": "continueRegularOutput",
      "notes": "REQ-ING-004: Archive raw HTML to Azure Blob Storage"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO items (\n  source_id,\n  url,\n  url_hash,\n  content_hash,\n  title,\n  content,\n  content_html,\n  author,\n  content_type,\n  published_at,\n  ingested_at,\n  status,\n  blob_path\n) VALUES (\n  $1::uuid,\n  $2,\n  $3,\n  $4,\n  $5,\n  $6,\n  $7,\n  $8,\n  $9::content_type,\n  $10::timestamptz,\n  NOW(),\n  'pending'::processing_status,\n  $11\n) RETURNING id",
        "options": {
          "queryReplacement": "={{ $json.source_id || $('Lookup Source Profile').item.json[0]?.source_id }},={{ $json.url }},={{ $json.url_hash }},={{ $json.sim_hash }},={{ $json.title }},={{ $json.content }},={{ $json.content_html }},={{ $json.author }},={{ $json.source_type }},={{ $json.published_at }},={{ $env.AZURE_BLOB_URL }}/nura-archive/{{ $json.url_hash }}.html"
        }
      },
      "id": "insert-item",
      "name": "Insert New Item",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [3340, 380],
      "credentials": {
        "postgres": {
          "id": "nura-postgres",
          "name": "Nura PostgreSQL"
        }
      },
      "notes": "Insert into items table with status='pending'"
    },
    {
      "parameters": {
        "method": "PUT",
        "url": "={{ $env.MINIFLUX_URL }}/v1/entries",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ entry_ids: [$json.raw_data?.id].filter(Boolean), status: 'read' }) }}",
        "options": {}
      },
      "id": "mark-read-miniflux",
      "name": "Mark Read in Miniflux",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [3560, 380],
      "credentials": {
        "httpHeaderAuth": {
          "id": "miniflux-auth",
          "name": "Miniflux API Key"
        }
      },
      "onError": "continueRegularOutput",
      "notes": "Mark RSS item as read after processing"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT record_workflow_success('WF1_Ingestion_RSS')",
        "options": {}
      },
      "id": "record-success-rss",
      "name": "Record Success RSS",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [3780, 300],
      "credentials": {
        "postgres": {
          "id": "nura-postgres",
          "name": "Nura PostgreSQL"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT record_workflow_success('WF1_Ingestion_Twitter')",
        "options": {}
      },
      "id": "record-success-twitter",
      "name": "Record Success Twitter",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [3780, 500],
      "credentials": {
        "postgres": {
          "id": "nura-postgres",
          "name": "Nura PostgreSQL"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT record_workflow_failure('WF1_Ingestion_RSS', $1)",
        "options": {
          "queryReplacement": "={{ JSON.stringify($json.error || 'Unknown error') }}"
        }
      },
      "id": "record-failure-rss",
      "name": "Record Failure RSS",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [1140, 140],
      "credentials": {
        "postgres": {
          "id": "nura-postgres",
          "name": "Nura PostgreSQL"
        }
      },
      "notes": "REQ-ING-005: Record failure for circuit breaker"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT record_workflow_failure('WF1_Ingestion_Twitter', $1)",
        "options": {
          "queryReplacement": "={{ JSON.stringify($json.error || 'Unknown error') }}"
        }
      },
      "id": "record-failure-twitter",
      "name": "Record Failure Twitter",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [1140, 760],
      "credentials": {
        "postgres": {
          "id": "nura-postgres",
          "name": "Nura PostgreSQL"
        }
      },
      "notes": "REQ-ING-005: Record failure for circuit breaker"
    },
    {
      "parameters": {},
      "id": "noop-skip-duplicate",
      "name": "Skip (Duplicate)",
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [2900, 560],
      "notes": "Item skipped due to deduplication"
    },
    {
      "parameters": {},
      "id": "noop-circuit-open",
      "name": "Skip (Circuit Open)",
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [920, 400],
      "notes": "REQ-ING-005: Circuit breaker is open, skip execution"
    }
  ],
  "connections": {
    "Schedule RSS (15min)": {
      "main": [
        [
          {
            "node": "Check Circuit Breaker RSS",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Schedule Twitter Priority (5min)": {
      "main": [
        [
          {
            "node": "Check Circuit Breaker Twitter",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Schedule Twitter Standard (15min)": {
      "main": [
        [
          {
            "node": "Check Circuit Breaker Twitter",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Circuit Breaker RSS": {
      "main": [
        [
          {
            "node": "IF Circuit Open RSS",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Circuit Breaker Twitter": {
      "main": [
        [
          {
            "node": "IF Circuit Open Twitter",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF Circuit Open RSS": {
      "main": [
        [
          {
            "node": "Miniflux Get Entries",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Skip (Circuit Open)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF Circuit Open Twitter": {
      "main": [
        [
          {
            "node": "Twitter API Priority",
            "type": "main",
            "index": 0
          },
          {
            "node": "Twitter API Standard",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Skip (Circuit Open)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Miniflux Get Entries": {
      "main": [
        [
          {
            "node": "Transform RSS Entries",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Record Failure RSS",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Twitter API Priority": {
      "main": [
        [
          {
            "node": "Transform Twitter Tweets",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Record Failure Twitter",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Twitter API Standard": {
      "main": [
        [
          {
            "node": "Transform Twitter Tweets",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Record Failure Twitter",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Transform RSS Entries": {
      "main": [
        [
          {
            "node": "Merge All Sources",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Transform Twitter Tweets": {
      "main": [
        [
          {
            "node": "Merge All Sources",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge All Sources": {
      "main": [
        [
          {
            "node": "Calculate Hashes (URL + SimHash)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Calculate Hashes (URL + SimHash)": {
      "main": [
        [
          {
            "node": "Check URL Hash Exists",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check URL Hash Exists": {
      "main": [
        [
          {
            "node": "IF URL New",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF URL New": {
      "main": [
        [
          {
            "node": "Get Recent SimHashes",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Skip (Duplicate)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Recent SimHashes": {
      "main": [
        [
          {
            "node": "Compare SimHash",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Compare SimHash": {
      "main": [
        [
          {
            "node": "IF Not Duplicate",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF Not Duplicate": {
      "main": [
        [
          {
            "node": "Lookup Source Profile",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Skip (Duplicate)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Lookup Source Profile": {
      "main": [
        [
          {
            "node": "Archive to Blob Storage",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Archive to Blob Storage": {
      "main": [
        [
          {
            "node": "Insert New Item",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Insert New Item": {
      "main": [
        [
          {
            "node": "Mark Read in Miniflux",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Mark Read in Miniflux": {
      "main": [
        [
          {
            "node": "Record Success RSS",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1",
    "saveManualExecutions": true,
    "callerPolicy": "workflowsFromSameOwner",
    "errorWorkflow": ""
  },
  "versionId": "wf1-ingestion-v2.0",
  "meta": {
    "templateCredsSetupCompleted": false,
    "instanceId": "nura-neural"
  },
  "id": "WF1_Ingestion",
  "tags": [
    {
      "id": "ingestion",
      "name": "ingestion"
    },
    {
      "id": "mvp",
      "name": "mvp"
    }
  ],
  "staticData": null,
  "pinData": {},
  "__meta": {
    "requirements": ["REQ-ING-001", "REQ-ING-002", "REQ-ING-003", "REQ-ING-004", "REQ-ING-005"],
    "description": "Content Ingestion Pipeline: RSS feeds via Miniflux + Twitter API v2 with deduplication, archival, and circuit breaker",
    "cost_target": "$0.00 per execution (no AI calls)",
    "schedule": "RSS: every 15 min | Twitter Priority: every 5 min | Twitter Standard: every 15 min"
  }
}
