{
  "name": "WF5: State Proxy Detection",
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "cronExpression",
              "expression": "0 0 * * 0"
            }
          ]
        }
      },
      "id": "schedule-weekly",
      "name": "Weekly Schedule (Sunday 00:00 UTC)",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [260, 300],
      "notes": "REQ-AI-005: Run weekly on Sunday at midnight UTC"
    },
    {
      "parameters": {
        "operation": "select",
        "query": "SELECT check_workflow_health('WF5_Proxy_Detection') as can_proceed",
        "options": {}
      },
      "id": "check-circuit",
      "name": "Check Circuit Breaker",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [480, 300],
      "credentials": {
        "postgres": {
          "id": "nura-postgres",
          "name": "Nura PostgreSQL"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "circuit-check",
              "leftValue": "={{ $json.can_proceed }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "if-circuit-open",
      "name": "IF Circuit Open",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [700, 300]
    },
    {
      "parameters": {
        "operation": "select",
        "query": "SELECT sp.id, sp.name, sp.identifier, sp.source_class, sp.base_score,\n       COUNT(i.id) as item_count,\n       ARRAY_AGG(DISTINCT i.content_hash) FILTER (WHERE i.content_hash IS NOT NULL) as content_hashes\nFROM source_profiles sp\nLEFT JOIN items i ON i.source_id = sp.id \n  AND i.published_at > NOW() - interval '90 days'\nWHERE sp.source_class IN ('indie_media', 'citizen_journalist', 'unknown')\n  AND sp.source_class != 'proxy_suspected'\nGROUP BY sp.id, sp.name, sp.identifier, sp.source_class, sp.base_score\nHAVING COUNT(i.id) >= 5",
        "options": {}
      },
      "id": "get-candidate-sources",
      "name": "Get Candidate Sources",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [920, 300],
      "credentials": {
        "postgres": {
          "id": "nura-postgres",
          "name": "Nura PostgreSQL"
        }
      },
      "notes": "REQ-AI-005: Get indie/citizen sources with ≥5 items in 90 days"
    },
    {
      "parameters": {
        "operation": "select",
        "query": "SELECT i.id, i.source_id, i.content_hash, i.narrative_id, sp.name as source_name\nFROM items i\nJOIN source_profiles sp ON i.source_id = sp.id\nWHERE sp.source_class IN ('state_media', 'regime_media')\n  AND i.published_at > NOW() - interval '90 days'\n  AND i.content_hash IS NOT NULL",
        "options": {}
      },
      "id": "get-regime-media-items",
      "name": "Get Regime Media Items (90 days)",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [1140, 300],
      "credentials": {
        "postgres": {
          "id": "nura-postgres",
          "name": "Nura PostgreSQL"
        }
      },
      "notes": "Get state/regime media content for comparison"
    },
    {
      "parameters": {
        "jsCode": "// REQ-AI-005: Calculate Content Overlap Component (C1 - 30%)\n// Compare SimHash of candidate source items vs regime media items\n// Hamming distance ≤ 6 indicates ≥90% similarity\n\nconst candidate = $('Get Candidate Sources').item.json;\nconst regimeItems = $input.first().json;\n\n// Handle single item or array\nconst regimeArray = Array.isArray(regimeItems) ? regimeItems : (regimeItems?.id ? [regimeItems] : []);\n\nfunction hammingDistance(hash1, hash2) {\n  if (!hash1 || !hash2) return 64;\n  try {\n    const h1 = BigInt('0x' + hash1);\n    const h2 = BigInt('0x' + hash2);\n    let xor = h1 ^ h2;\n    let count = 0;\n    while (xor > 0n) {\n      count += Number(xor & 1n);\n      xor >>= 1n;\n    }\n    return count;\n  } catch (e) {\n    return 64;\n  }\n}\n\n// Get candidate's content hashes\nconst candidateHashes = candidate.content_hashes || [];\n\n// Count overlaps\nlet highSimilarityCount = 0;\nlet totalComparisons = 0;\nconst overlappingItems = [];\n\nfor (const candidateHash of candidateHashes) {\n  for (const regimeItem of regimeArray) {\n    if (!regimeItem.content_hash) continue;\n    totalComparisons++;\n    const distance = hammingDistance(candidateHash, regimeItem.content_hash);\n    if (distance <= 6) {\n      highSimilarityCount++;\n      overlappingItems.push({\n        regime_source: regimeItem.source_name,\n        regime_item_id: regimeItem.id,\n        hamming_distance: distance\n      });\n    }\n  }\n}\n\n// C1 score: ratio of high-similarity matches * 100 (0-100 scale)\nconst overlapRatio = candidateHashes.length > 0 \n  ? highSimilarityCount / candidateHashes.length \n  : 0;\nconst c1_score = Math.min(100, overlapRatio * 100);\n\nreturn [{\n  json: {\n    ...candidate,\n    c1_content_overlap: c1_score,\n    c1_details: {\n      high_similarity_count: highSimilarityCount,\n      total_candidate_items: candidateHashes.length,\n      overlap_ratio: overlapRatio.toFixed(3),\n      overlapping_items: overlappingItems.slice(0, 10) // Top 10 examples\n    }\n  }\n}];"
      },
      "id": "calc-content-overlap",
      "name": "C1: Content Overlap (30%)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1360, 300],
      "notes": "REQ-AI-005: SimHash similarity ≥90% (Hamming ≤6)"
    },
    {
      "parameters": {
        "operation": "select",
        "query": "WITH candidate_narratives AS (\n  SELECT DISTINCT i.narrative_id\n  FROM items i\n  WHERE i.source_id = $1::uuid\n    AND i.narrative_id IS NOT NULL\n),\nregime_narratives AS (\n  SELECT DISTINCT i.narrative_id\n  FROM items i\n  JOIN source_profiles sp ON i.source_id = sp.id\n  WHERE sp.source_class IN ('state_media', 'regime_media')\n    AND i.narrative_id IS NOT NULL\n    AND i.published_at > NOW() - interval '90 days'\n)\nSELECT \n  COUNT(*) as shared_narrative_count,\n  (SELECT COUNT(*) FROM candidate_narratives) as candidate_narrative_total,\n  ARRAY_AGG(cn.narrative_id) as shared_narratives\nFROM candidate_narratives cn\nJOIN regime_narratives rn ON cn.narrative_id = rn.narrative_id",
        "options": {
          "queryReplacement": "={{ $json.id }}"
        }
      },
      "id": "calc-narrative-alignment",
      "name": "Query Narrative Alignment",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [1580, 300],
      "credentials": {
        "postgres": {
          "id": "nura-postgres",
          "name": "Nura PostgreSQL"
        }
      },
      "notes": "REQ-AI-005: C2 - Shared narratives with regime media"
    },
    {
      "parameters": {
        "jsCode": "// REQ-AI-005: Calculate Narrative Alignment Component (C2 - 30%)\nconst candidate = $('C1: Content Overlap (30%)').item.json;\nconst alignment = $input.first().json;\n\nconst sharedCount = parseInt(alignment.shared_narrative_count) || 0;\nconst totalCount = parseInt(alignment.candidate_narrative_total) || 1;\n\n// C2 score: ratio of shared narratives * 100 (0-100 scale)\nconst alignmentRatio = totalCount > 0 ? sharedCount / totalCount : 0;\nconst c2_score = Math.min(100, alignmentRatio * 100);\n\nreturn [{\n  json: {\n    ...candidate,\n    c2_narrative_alignment: c2_score,\n    c2_details: {\n      shared_narratives: sharedCount,\n      total_narratives: totalCount,\n      alignment_ratio: alignmentRatio.toFixed(3),\n      shared_narrative_ids: alignment.shared_narratives || []\n    }\n  }\n}];"
      },
      "id": "calc-c2-score",
      "name": "C2: Narrative Alignment (30%)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1800, 300],
      "notes": "REQ-AI-005: Shared narrative ratio"
    },
    {
      "parameters": {
        "jsCode": "// REQ-AI-005: Calculate ProxyScore\n// MVP: C1 (30%) + C2 (30%) only\n// C3 (Timing Patterns) and C4 (Funding Transparency) = 0 for MVP\n\nconst candidate = $input.first().json;\n\nconst c1 = candidate.c1_content_overlap || 0;\nconst c2 = candidate.c2_narrative_alignment || 0;\nconst c3 = 0; // MVP: Not implemented\nconst c4 = 0; // MVP: Not implemented\n\n// ProxyScore formula (weighted average)\n// Full formula: (C1*0.30) + (C2*0.30) + (C3*0.25) + (C4*0.15)\n// MVP formula: (C1*0.30) + (C2*0.30) = max 60 points\n// Normalize to 0-100 by scaling up: (C1 + C2) / 2 for MVP\nconst proxyScoreRaw = (c1 * 0.30) + (c2 * 0.30);\nconst proxyScore = proxyScoreRaw / 0.60 * 100; // Normalize to 0-100\n\n// Threshold: ≥70 = proxy suspected\nconst isProxySuspected = proxyScore >= 70;\n\nreturn [{\n  json: {\n    ...candidate,\n    proxy_score: Math.round(proxyScore),\n    is_proxy_suspected: isProxySuspected,\n    score_components: {\n      c1_content_overlap: c1,\n      c2_narrative_alignment: c2,\n      c3_timing_patterns: c3,\n      c4_funding_transparency: c4,\n      weights: { c1: 0.30, c2: 0.30, c3: 0.25, c4: 0.15 },\n      mvp_note: 'C3 and C4 not implemented in MVP'\n    }\n  }\n}];"
      },
      "id": "calc-proxy-score",
      "name": "Calculate ProxyScore",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2020, 300],
      "notes": "REQ-AI-005: ProxyScore = (C1*0.30) + (C2*0.30)"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "proxy-check",
              "leftValue": "={{ $json.is_proxy_suspected }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "if-proxy-suspected",
      "name": "IF ProxyScore ≥ 70",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [2240, 300]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $env.AZURE_OPENAI_ENDPOINT }}/openai/deployments/{{ $env.AZURE_OPENAI_DEPLOYMENT }}/chat/completions?api-version=2024-02-15-preview",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"messages\": [\n    {\n      \"role\": \"system\",\n      \"content\": \"You are a media analyst. Write a brief (2-3 sentence) factual explanation for why this news source may be operating as a proxy for state media. Base your explanation on the evidence provided. Be objective and avoid speculation.\"\n    },\n    {\n      \"role\": \"user\",\n      \"content\": {{ JSON.stringify('Source: ' + $json.name + '\\nProxyScore: ' + $json.proxy_score + '/100\\n\\nEvidence:\\n- Content overlap with state media: ' + $json.c1_content_overlap.toFixed(1) + '% (found ' + $json.c1_details.high_similarity_count + ' highly similar items)\\n- Narrative alignment: ' + $json.c2_narrative_alignment.toFixed(1) + '% (' + $json.c2_details.shared_narratives + ' shared narratives with state media)') }}\n    }\n  ],\n  \"temperature\": 0.3,\n  \"max_tokens\": 200\n}",
        "options": {
          "timeout": 30000
        }
      },
      "id": "generate-explanation",
      "name": "Generate LLM Explanation",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [2460, 200],
      "credentials": {
        "httpHeaderAuth": {
          "id": "azure-openai-auth",
          "name": "Azure OpenAI API Key"
        }
      },
      "onError": "continueErrorOutput",
      "notes": "Generate human-readable explanation for review"
    },
    {
      "parameters": {
        "jsCode": "// Parse LLM explanation\nconst candidate = $('Calculate ProxyScore').item.json;\nconst response = $input.first().json;\n\nlet explanation = 'Proxy score threshold exceeded based on content and narrative analysis.';\ntry {\n  if (response.choices && response.choices[0]) {\n    explanation = response.choices[0].message.content.trim();\n  }\n} catch (e) {\n  // Use default explanation\n}\n\nreturn [{\n  json: {\n    ...candidate,\n    proxy_explanation: explanation\n  }\n}];"
      },
      "id": "parse-explanation",
      "name": "Parse Explanation",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2680, 200]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "UPDATE source_profiles SET\n  source_class = 'proxy_suspected',\n  base_score = 20,\n  updated_at = NOW()\nWHERE id = $1::uuid\nRETURNING id, name, source_class",
        "options": {
          "queryReplacement": "={{ $json.id }}"
        }
      },
      "id": "update-source-profile",
      "name": "Reclassify to PROXY_SUSPECTED",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [2900, 200],
      "credentials": {
        "postgres": {
          "id": "nura-postgres",
          "name": "Nura PostgreSQL"
        }
      },
      "notes": "REQ-AI-005: Reclassify and set base_score=20"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO proxy_audits (\n  source_id,\n  proxy_score,\n  component_scores,\n  evidence,\n  explanation,\n  detected_at,\n  reviewed\n) VALUES (\n  $1::uuid,\n  $2,\n  $3::jsonb,\n  $4::jsonb,\n  $5,\n  NOW(),\n  false\n)\nRETURNING id",
        "options": {
          "queryReplacement": "={{ $json.id }},={{ $json.proxy_score }},={{ JSON.stringify($json.score_components) }},={{ JSON.stringify({ c1_details: $json.c1_details, c2_details: $json.c2_details }) }},={{ $json.proxy_explanation }}"
        }
      },
      "id": "log-audit",
      "name": "Log to proxy_audits",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [3120, 200],
      "credentials": {
        "postgres": {
          "id": "nura-postgres",
          "name": "Nura PostgreSQL"
        }
      },
      "notes": "REQ-AI-005: Audit trail for human review"
    },
    {
      "parameters": {
        "jsCode": "// Collect all proxy detections for summary report\nconst items = $input.all();\n\nconst proxySuspected = items.filter(i => i.json.is_proxy_suspected);\nconst notSuspected = items.filter(i => !i.json.is_proxy_suspected);\n\nconst reportDate = new Date().toISOString().split('T')[0];\n\nconst report = {\n  report_date: reportDate,\n  total_sources_analyzed: items.length,\n  proxy_suspected_count: proxySuspected.length,\n  clear_count: notSuspected.length,\n  detections: proxySuspected.map(p => ({\n    source_name: p.json.name,\n    proxy_score: p.json.proxy_score,\n    content_overlap: p.json.c1_content_overlap?.toFixed(1) + '%',\n    narrative_alignment: p.json.c2_narrative_alignment?.toFixed(1) + '%',\n    explanation: p.json.proxy_explanation\n  }))\n};\n\nreturn [{\n  json: report\n}];"
      },
      "id": "compile-report",
      "name": "Compile Weekly Report",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [3340, 300]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO monitoring_logs (workflow_id, level, message, metadata, created_at)\nVALUES ('WF5', 'info', 'Weekly proxy detection completed', $1::jsonb, NOW())",
        "options": {
          "queryReplacement": "={{ JSON.stringify($json) }}"
        }
      },
      "id": "log-report",
      "name": "Log Report to DB",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [3560, 300],
      "credentials": {
        "postgres": {
          "id": "nura-postgres",
          "name": "Nura PostgreSQL"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT record_workflow_success('WF5_Proxy_Detection')",
        "options": {}
      },
      "id": "record-success",
      "name": "Record Success",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [3780, 300],
      "credentials": {
        "postgres": {
          "id": "nura-postgres",
          "name": "Nura PostgreSQL"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT record_workflow_failure('WF5_Proxy_Detection', $1)",
        "options": {
          "queryReplacement": "={{ JSON.stringify({ error: $json.error || 'Unknown error' }) }}"
        }
      },
      "id": "record-failure",
      "name": "Record Failure",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [2460, 100],
      "credentials": {
        "postgres": {
          "id": "nura-postgres",
          "name": "Nura PostgreSQL"
        }
      }
    },
    {
      "parameters": {},
      "id": "noop-circuit-open",
      "name": "Skip (Circuit Open)",
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [920, 400]
    },
    {
      "parameters": {},
      "id": "noop-not-suspected",
      "name": "Not Suspected (Pass)",
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [2460, 400],
      "notes": "Source passed proxy check"
    }
  ],
  "connections": {
    "Weekly Schedule (Sunday 00:00 UTC)": {
      "main": [
        [
          {
            "node": "Check Circuit Breaker",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Circuit Breaker": {
      "main": [
        [
          {
            "node": "IF Circuit Open",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF Circuit Open": {
      "main": [
        [
          {
            "node": "Get Candidate Sources",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Skip (Circuit Open)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Candidate Sources": {
      "main": [
        [
          {
            "node": "Get Regime Media Items (90 days)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Regime Media Items (90 days)": {
      "main": [
        [
          {
            "node": "C1: Content Overlap (30%)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "C1: Content Overlap (30%)": {
      "main": [
        [
          {
            "node": "Query Narrative Alignment",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Query Narrative Alignment": {
      "main": [
        [
          {
            "node": "C2: Narrative Alignment (30%)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "C2: Narrative Alignment (30%)": {
      "main": [
        [
          {
            "node": "Calculate ProxyScore",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Calculate ProxyScore": {
      "main": [
        [
          {
            "node": "IF ProxyScore ≥ 70",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF ProxyScore ≥ 70": {
      "main": [
        [
          {
            "node": "Generate LLM Explanation",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Not Suspected (Pass)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate LLM Explanation": {
      "main": [
        [
          {
            "node": "Parse Explanation",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Record Failure",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Explanation": {
      "main": [
        [
          {
            "node": "Reclassify to PROXY_SUSPECTED",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Reclassify to PROXY_SUSPECTED": {
      "main": [
        [
          {
            "node": "Log to proxy_audits",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Log to proxy_audits": {
      "main": [
        [
          {
            "node": "Compile Weekly Report",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Not Suspected (Pass)": {
      "main": [
        [
          {
            "node": "Compile Weekly Report",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Compile Weekly Report": {
      "main": [
        [
          {
            "node": "Log Report to DB",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Log Report to DB": {
      "main": [
        [
          {
            "node": "Record Success",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1",
    "saveManualExecutions": true,
    "callerPolicy": "workflowsFromSameOwner"
  },
  "versionId": "wf5-proxy-detection-v2.0",
  "meta": {
    "templateCredsSetupCompleted": false,
    "instanceId": "nura-neural"
  },
  "id": "WF5_Proxy_Detection",
  "tags": [
    {
      "id": "proxy",
      "name": "proxy"
    },
    {
      "id": "detection",
      "name": "detection"
    },
    {
      "id": "weekly",
      "name": "weekly"
    }
  ],
  "__meta": {
    "requirements": ["REQ-AI-005"],
    "description": "State Proxy Detection: Weekly analysis of indie/citizen sources for state media affiliation via content overlap and narrative alignment",
    "cost_target": "$0.10/week (LLM for explanations on detections only)",
    "schedule": "Weekly: Sunday 00:00 UTC",
    "scoring_formula": "ProxyScore = (C1_ContentOverlap * 0.30) + (C2_NarrativeAlignment * 0.30) | MVP: C3, C4 = 0",
    "threshold": "ProxyScore ≥ 70 = PROXY_SUSPECTED, base_score set to 20"
  }
}
    }
  ],
  "connections": {},
  "active": false,
  "settings": {},
  "meta": {
    "description": "REQ-AI-005: Weekly batch job to detect INDIE_MEDIA and CITIZEN_JOURNALIST sources that are state-controlled proxies. Uses content overlap (SimHash) and narrative alignment analysis. Auto-reclassifies sources with ProxyScore ≥ 70.",
    "requirements": [
      "REQ-AI-005: State Proxy Detection Algorithm",
      "Content Overlap (30%): SimHash similarity ≥90%",
      "Narrative Alignment (30%): Shared narratives without contradiction",
      "Amplification Network (20%): MVP = 0 (Phase 2)",
      "Technical Overlap (20%): MVP = 0 (Phase 2)"
    ],
    "schedule": "Every Sunday 00:00 UTC",
    "cost_target": "$0.10/month (LLM for explanations only)"
  }
}
